# Mutation

- [Mutation](#mutation)
  - [Mutation in Racket](#mutation-in-racket)
    - [Example](#example)
    - [Implementation in impure Racket](#implementation-in-impure-racket)
    - [Application](#application)
      - [Consider](#consider)
  - [Mutation in C](#mutation-in-c)
    - [Assignment](#assignment)
    - [Global Variables](#global-variables)
    - [Repetition](#repetition)
      - [recursion](#recursion)
      - [while loop](#while-loop)
      - [Common Pattern](#common-pattern)
      - [Updating Counters](#updating-counters)
  - [Intermediate Mutation (Racket)](#intermediate-mutation-racket)
  - [Intermediate Mutation (C)](#intermediate-mutation-c)
    - [Structure in C](#structure-in-c)
    - [Pointer](#pointer)
  - [Advance Mutation](#advance-mutation)
    - [Mutating structures and lists](#mutating-structures-and-lists)
    - [Semantics](#semantics)
    - [Rethinking define](#rethinking-define)
    - [Array (C)](#array-c)
    - [Vector (Racket)](#vector-racket)
      - [Memory Allocation](#memory-allocation)

***

## Mutation in Racket

```scheme
(define x 3)
(set! x 4)
x
=> 4
```

### Example

```scheme
(lookup 'Rob)
=> false
(add 'Rob 3)
(lookup 'Rob)
=> 3
```

### Implementation in impure Racket

```scheme
(define address-book empty) ;; global variable
(define (add name number)
(set! address-book
  (cons (list name number) address-book))
```

**Global data**: good for defining constants going to be used repeatedly.

- But not great with mutations
- Any part of the program could change global
- Affects the entire program
- Hidden dependencies between different parts of the program
- Harder to reason about programs

### Application

- **Caching**: Saving the result of computation to avoid repeating
- **Memoization**: maintaining a list or table of cached values

#### Consider

```scheme
(define (fib n)
  (cond
    [(= n 0) 0]
    [(= n 1) 1]
    [else (+ (fib (- n 1))
             (fib (- n 2)))]))
```

It is inefficient becasue recursive calls are repeated doing the same computation:

- `(fib 98)` called twice, `(fib 97)` called three times
- `(fib n)` is $\theta$`(f n)`
- To avoid repetition, we can keep an associated list of already computed value

```scheme
(define fib-table empty)

(define (memo-fib n)
  (define result (assoc n fib-table))
  (cond
    [result => second]
    ;; [cond => f] -> if cond is true, then evaluate (f cond)
    [else
     (define fib-n
       (cond
         [(<= n 1) n]
         [else (+ (memo-fib (- n 1))
                  (memo-fib (- n 2)))]))
     (set! fib-table (cons (list n fib-n) fib-table))
     fib-n]))
```

- Now fib-table is a global variable. Can we hide it?

```scheme
(define memo-fib2
  (local
    [(define fib-table empty)
     (define (memo-fib n)
       (define result (assoc n fib-table))
       (cond
         [result => second]
         [else
          (define fib-n
            (cond
              [(<= n 1) n]
              [else (+ (memo-fib (- n 1))
                       (memo-fib (- n 2)))]))
          (set! fib-table (cons (list n fib-n) fib-table))
          fib-n]))]
    (Î» (n) (memo-fib n))))
```

- We can also keep the computed value in the accumulator

```scheme
(define (accum-fib-helper n acc)
  (define result (assoc n acc))
  (cond
    [result acc]
    [else
     (define next-acc (accum-fib-helper (- n 1) (accum-fib-helper (- n 2) acc)))
     (cons (list n (+ (second (assoc (- n 1) next-acc))
                      (second (assoc (- n 2) next-acc))))
           next-acc)]))

(define (accum-fib n)
  (second (assoc n (accum-fib-helper n (list (list 0 0) (list 1 1))))))
```

***

## Mutation in C

### Assignment

- assignment operator: `=`

```C
// mutate x to have the value 5
// equivalent to (set! x 5) in racket
x = 5
```

- `x = 4` sets x to 4, produces 4

```C
int main() {
  int x = 3;
  printf("%d\n", x); // print 3
  printf("%d\n", x = 4); // print 4
}
```

- advantage

```C
x = y = z = 7; // sets x, y, z to 7
```

- disadvantage that often leads to errors

```C
int main() {
  int x = 5;
  if (x = 4) { // error: should use "==" instead of "="
    printf("%d\n", x); // print 4
  }
}
```

- can leave variables uninitialized and assign later

```C
int main() {
  int x; // uninitialized
  x = 4; // assignment
}
```

```C
int x;
if (x == 0) { // Will this run or not?
              // don't know. x's value undefined
}
// Typically its value will be whatever was in the memory before it
```

***

### Global Variables

```C
int c = 0;

int f() {
  int d = c;
  c = c + 1;
  return d;
}

int main() {
  printf("%d\n", f()); // print 0
  printf("%d\n", f()); // print 1
  printf("%d\n", f()); // print 2
}
```

> ***Careful***:
> `printf("%d\n %d\n %d\n", f(), f(), f());`
>
> could produce: `0 1 2` or `2 1 0` or `1 0 2` ......

Can we hide c within f, as we did in fib-table?

```C
int f() {
  static int c = 0; // c is a global variable
  int d = c;
  c = c + 1;
  return d;
}
```

Global constants can still be helpful! We can force a variable to be constant in C

```C
const int passingGrade = 50;
```

***

### Repetition

#### recursion

```C
void sayHiNTimes(int n) {
  if (n > 0) {
    printf("hi!\n");
    sayHiNTimes(n-1);
  }
}
```

***

#### while loop

```C
void sayHiNTimes(int n) {
  while (n > 0) {
    printf("hi!\n");
    n = n = 1;
  }
}
```

>a loop - the body of a loop is a group executed repeatedly so long as the condtion remains true.

*Loops and recursions are mathematically equivalent.*

***

#### Common Pattern

```C
(initialize vars)
while (condition) {
  (body)
  (update)
}
```

or

```C
for (init; condition; update) {
  (body)
}
```

***

#### Updating Counters

- short hands

```C
c += 1; // c = c + 1;
c -= 2; // c = c - 2;
c *= 10; // c = c * 10;
c /= 2; // c = c / 2;
```

- incrementing and decrementing by 1

```C
// prefix: produces the new value of i
// ++i;
// --i;
int i = 1;
printf("%d", ++i); // prints 2

// postfix: produces the old value of i
// i++;
// i--;
int j = 1;
printf("%d", j++); // prints 1
printf("%d", j); // prints 2
```

>Postfix operation implies you must remember the old value. So, if you don't care about value produced, prefer to use prefix

***

## Intermediate Mutation (Racket)

What if we want to work with multiple address books?

```scheme
(define work '(("manager" 12345)
               ("director" 123456)))
```

Solution:

```scheme
(define home '())

(define (add-entry abook aname anumber)
  (set! abbok (cons (list aname anumber) abook)))

(add-entry home "Neighbour" 34567)

> home
> '() ; No Change!
```

- Code doesn't work
- Not immediately clear how to make it work
- substitution model does not explain the behavior
- Effectively, we are doing `(set! '() (cons (list "Neighbour" 34567) '()))`
- We can not change the meaning of an empty list
- To make this work, we need to use Lambda
- Do the same thing to creat a struct with one field called a box:
  - Two operations:
    - get the value in the box
    - set the value in the box

```scheme
(define (make-box v)
  (lambda (msg)
    (cond
      [(equal? msg 'get) val]
      [(equal? msg 'set)
       (lambda (newVal) (set! val newVal))])))

(define (get b) (b 'get))

(define b1 (make-box 7))

> (get b1)
> 7

> ((set b1) 5)
> (get b1)
> 5
```

Boxes are built in to racket

*Syntax:*

```scheme
exp = (box exp)
    | (unbox exp)
    | (set-box! exp exp) ; first argument doesn't need to be an id

(define work (box '(Personel 123456)))
(define (add book name number)
  (set-box! book (cons (list name number) (unbox book))))
```

*Semantics:*

```scheme
(box v) ; v is a value
=> (define _u v) ; u is a fresh name number
;; Convention: when we write an _ before a var, it means the var's value is not looked up during expr evaluation unless its after unbox

(unbox _n) ;; find (define _n v)
=> v
```

*e.g.*

```scheme
(define box1 (box 4))
(unbox box1)
(set-box! box1 true)
(unbox box1)

;; step 1
=> (define _u1 4)
=> (define box1 _u1)
=> (unbox box1)
=> (set-box! box1 true)
=> (unbox box1)

;; step 2
=> (define _u1 4)
=> (define box1 _u1)
=> (unbox _u1)
=> (set-box! box1 true)
=> (unbox box1)

;; step 3
=> (define _u1 4)
=> (define box1 _u1)
=> 4
=> (set-box! box1 true)
=> (unbox box1)

;; step 4
=> (define _u1 4)
=> (define box1 _u1)
=> 4
=> (set! _u1 true)
=> (unbox box1)

;; step 5
=> (define _u1 4)
=> (define box1 _u1)
=> 4
=> (set! _u1 true)
=> (unbox _u1)

;; step 6
=> (define _u1 4)
=> (define box1 _u1)
=> 4
=> (set! _u1 true)
=> true
```

## Intermediate Mutation (C)

Suppose we want to write a function

```C
void inc(int x) {
  x = x + 1;
}

int main() {
  int x = 1;
  inc(x);
  printf("%d", x); // prints 1, we want it to print 2
}
```

Racket solution is to put it in a box. What is a box in C?

### Structure in C

```C
struct Posn {
  int x;
  int y;
};

int main() {
  struct Posn p;
  p.x = 3;
  p.y = 4;
  printf("%d, %d", p.x, p.y); // prints 3, 4
}

// or
int main() {
  struct Posn p = {3, 4};
}

// but not
int main() {
  struct Posn p;
  p = {3, 4};
}
```

*Does it work like boxes in Racket?*

```C
void swap(struct Posn p) {
  int temp = p.x;
  p.x = p.y;
  p.y = temp;
}

int main() {
  struct Posn p = {3, 4};
  swap(p);
  printf("%d, %d", p.x, p.y); // still prints 3, 4
}
```

**The Problem**: C (and also Racket) pass parameters by a machanism know as call by value. The function operates on a copy of the values of the arguments, not the arguments themselves.

### Pointer

```C
void inc(int x) {
  ++x; // only the local copy of x is being mutated
}
```

So, something speical about boxes

- Not equal to the value it holds
- But can tell you how to get the value
- unbox = find the value

Finding a value? Where is that value located?

- in memory (RAM)
- Every value in memory has an address
- given the address we can find the value

So address could function as boxes. Instead of passing the value, pass an address

```C
void inc(int x) {
  x = x + 1;
}

int main() {
  int x = 1;
  inc(&x); // & is the "address-of" operator
  printf("%d", x);
}
```

A few things are wrong:

- Tpes don't match anymore. We must update the parameter's type to be "int* p" - a pointer to an int
- Body is also wrong, Now: `x = x + 1` means that add 1 to the address (whatever that means) and overwrite our local copy of the address with that value.

Correct Version:

```C
void inc(int* x) {
  *x += 1;
}

// or
void inc(int* x) {
  ++*x;
}

// wrong
void inc(int* x) {
  *x++; // = *(x++) address is incremented
}
```

Consider

```C
void swap(struct Posn p) {
  int temp = p.x;
  p.x = p.y;
  p.y = temp;
} // only the local copy is mutated
```

Now we can fix this using the pointer

```C
void swap(struct Posn* p) {
  int temp = *p.x; // wrong! postfix before prefix
  *p.x = *p.y;
  *p.y = temp;
  // *(p.x) = *(p.y) and they are not pointers, also p doesn't have x and y filed because it is a pointer
}

// correct version
void swap(struct Posn* p) {
  int temp = (*p).x;
  (*p).x = (*p).y;
  (*p).y = temp;
}

// or
void swap(struct Posn* p) {
  int temp = (*p).x;
  p->x = p->y; // p->x = (*p).x
  p->y = temp;
}
```

Now we can use a more sophisticated input function `scanf`

- `scanf("%d", &x);`
- reads x as a decimal integer
- skips leading whitespace
- returns the number of arguments successfully read

```C
int main() {
  int x, y;
  int n = scanf("%d %d", &x, &y); // whitespace means skipping any amount of whitespace, including zero
  printf("%d", n); // prints 2;
}
```

## Advance Mutation

### Mutating structures and lists

- In scheme: can mumate the part of a cons with set-car! and set-cdr!
- In racket: cons fileds are inmmutable, for mutable pairs we use `mcons`, `mset-car!`, and `mset-cdr!`
- For structs: provide the option `#:mutable`

```scheme
(struct posn (x y) #:mutable)
(define p (make-posn 3 4))
(set-posn-x! p 5)
(posn-x p) => 5
```

### Semantics

- before: `(make-posn v1 v2)` is a value
- now: `(make-posn v1 v2)` cannot simply be a value if its mutable. It has to behave more like a box.
- it turns out that in racket a struct itself is not boxed, but its fields are automatically boxed.

So we can rewrite `(posn v1 v2)` as

```scheme
(define _val1 v1) ; _ = no expansion
(define _val2 v2)
(define p (posn _val1 _val2))
(posn-x p) ;; find the defn for _val1 and fetch the value
(set-posn-x! p v) ;; find (define _val1 v1) and replace it with (define _val1 v)
```

Generalized to any mutable structs, mcons

Consider

```scheme
(define lst1 (cons (box 1) empty))
(define lst2 (cons 2 lst1))
(define lst3 (cons 3 lst1))

(set-box! (first (rest lst2)) 4)
(unbox (first (rest lst3))) ;; return 4

;; lst2 and lst3 shares the same tail
;; (first (rest lst2)) and (first (rest lst3)) refers to the same object
```

### Rethinking define

```scheme
(define x 3)
(set! x 7)
```

x is not just a value, its something we can mutate. x must denote a location and it's the location that contains the value.

In C, consider:

```C
int main() {
  int x = 1;
  int* y = &x; // y stores the address of x
  int* z = y; // z stores y which is the address of x
  *y = 2; // take the value of y and treat it as an address
  *z = 3; // take the value of z and treat it as an address
  printf("%d, %d, %d", x, y, z); // prints 3, 3, 3
}
```

In this case, *y, *z are aliases of x.

It can be subtle, or seemingly unintuitive

```C
void f(int *x, int *y) {
  *y = *x + 1;
  if (*x == *y) {
    printf("Hello!\n");
  }
}

int main() {
  int z = 1;
  f(&z, &z);
}

// This would print "Hello!"
```

### Array (C)

- primitive data structure
- a slice of memory
- a sequence of consective locations, we'll talk about this in depth when we come back

### Vector (Racket)

- used much like the traditional array
- unlike out arrays, they can store data of any size
- length of memory is chosen by the program
- width is any value (can be infinitely large)

```scheme
(define x (vector 'blue true "you")) ; 3 item vector
(define u (make-vector 100)) ; create a vector of length 100
(define z (build-vector 100 sqr)) ; similar to build-list
(define y (make-vector 100 5)) ; vector of length 100 with value 5
(vector-ref x 7); value of x at index 7
(vector-set! dy 7 42); set the value of x at index 7 to 42
```

Main advantages of vectors over lists

- vector-ref and vector-set! take O(1)

Disadvantages

- size is fixed
- difficult to add or remove elements
- vector-set! tends to force an imperative style

```scheme
(define (my-build-vector n f)
  (define res (make-vector n))
  (define (mbv-h i)
    (if (= i n)
        res
        (begin
          (vector-set! res i (f i))
          (mbv-h (+ i 1)))))
  (mbv-h 0))
```

Vectors lend themselves well to an imperative style. for, for/vector macros in Racket allow this.

```scheme
(define (my-build-vector n)
  (define res (make-vector n))
  (for ([i n]) ;; for macro
    (vector-set! res i (f i))
  res))

(define (my-build-vector n f)
  (for/vector ([i n]) (f i))) ; for/vector macro```
```

Sum the values in a vector

```scheme
(define (sum-vector n)
  (define acc 0)
  (for ([i (vector-length n)] (set! acc (+ acc (vector-ref n i))))))
```

This is not prue functional

- use mutatoin
- to the outside observer, this for appears to be pure functional
- mutation can't be called detected outside of the function

Provides a good method for managing the world with mutation: encapsulate it in a pure functional interface

#### Memory Allocation

Memory slots only hold fixed sizes, so how is racket storing in its simulation of arrays things like unbounded integer and strings.

Recall:

```scheme
(define (mutate-posn p)
  (set-posn-x! p (+ 1 (posn-x p))))

(define p (posn 3 4))
(mutate-posn p)
(posn-x p) => 4
```

VS

```C
void mutate(struct Posn p) {
  p.x = p.x + 1;
}

int main() {
  struct Posn p = {3 ,4};
  mutate(p);
  printf("%d\n", p.x); // 3
}
```

Racket structs are not like C structs

- The struct is copied, but changes to the fields persisted
- The fields of a racket struct are boxed, they are just pointers

Similarly, the items in a racket vector  are addresses.
